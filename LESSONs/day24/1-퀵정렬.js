// 3.4 퀵정렬(best - O(nlog2n) | worst - O(n**2))
// 피봇값(pivot)을 기준으로 정렬(피봇값은 처음값, 중간값, 마지막 값)
// 피봇값: 기준
// 실무에서는 worst일 경우를 피하기 위해 피봇을 랜덤하게 주는 경우나, 피봇을 2개 사용하는 경우도 있음.



/* 
피벗값은 순회를 돈다!!! 피벗값이 앞 뒤 기준이다!!
let 입력값 = [66, 77, 54, 32, 10, 5, 11, 15];


// step 1. 66을 기준으로 나머지 값들을 66 앞으로 보낼지, 뒤로 보낼지 정함
// 피봇값: 66
[54, 32, 10, 5, 11, 15] + *[66] + [77]


// step 2
// 피봇값: 54 (66과 77은 값이 한 개이기 때문에 더이상 재귀로 호출하지 않음)
[32, 10, 5, 11, 15] + *[54] + [66] + [77]

// step 3
// 피봇값: 32
[10, 5, 11, 15] + *[32] + [54] + [66] + [77]

// step 4
// 피봇값: 10
[5] + *[10] + [11, 15] + [32] + [54] + [66] + [77] 
//11과 15가 한꺼번에 뒤로 간 이유: 피벗값이!! 모든 인덱스를 순회해서 자기보다 작은건 앞으로, 큰건 뒤로 보내서 그래!!

// step 5
// 피봇값: 11
[5] + [10] + *[11] + [15] + [32] + [54] + [66] + [77]
*/


let 입력값 = [66, 77, 54, 32, 10, 5, 11, 15];

function 퀵정렬(입력배열) {
    let 입력배열의길이 = 입력배열.length

    if (입력배열의길이 <= 1) {
      // console.log(입력배열);
      return 입력배열
    }

    const 피벗값 = [입력배열.shift()] // 제일 앞에있는 값 빼서 넣기 (원본에서는 제거함)
    const 그룹하나 = []
    const 그룹둘 = []

    for (let i in 입력배열) { // 키 값으로 순회
        if (입력배열[i] < 피벗값) {
          그룹하나.push(입력배열[i]) // 피벗값보다 작은 값이면 피벗값 앞 자리에 삽입
        } else {
          그룹둘.push(입력배열[i])
        }
    }

    console.log(`그룹하나 : ${그룹하나}\n그룹둘 : ${그룹둘}\n피벗값 : ${피벗값}\n`);

    return 퀵정렬(그룹하나).concat(피벗값, 퀵정렬(그룹둘)) // 최종 결과 모두 합쳐 반환하기!
}

console.log(퀵정렬(입력값))
// 퀵정렬(입력값)